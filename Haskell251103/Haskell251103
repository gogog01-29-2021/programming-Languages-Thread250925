
give me core part and some part and key code summarization for these 500 pages that also some part that doesn't come out on here in depth knowledge such as Extension and grammar changing.


--Chapter3 syntax in functions
--Patern Matching
-- Basic pattern matching
lucky :: Int -> String
lucky 7 = "LUCKY NUMBER SEVEN!"
lucky x = "Sorry, you're out of luck, pal!"

-- Recursive patterns
factorial :: Int -> Int
factorial 0 = 1
factorial n = n * factorial (n - 1)

-- Tuple patterns
addVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)

-- List patterns
head' :: [a] -> a
head' [] = error "Can't call head on empty list"
head' (x:_) = x

-- As-patterns (keeping reference to whole)
firstLetter :: String -> String
firstLetter "" = "Empty string!"
firstLetter all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]

-- Guards with multiple parameters
bmiTell :: Double -> String
bmiTell bmi
    | bmi <= 18.5 = "Underweight"
    | bmi <= 25.0 = "Normal"
    | bmi <= 30.0 = "Overweight"
    | otherwise   = "Obese"

max' :: Ord a => a -> a -> a
max' a b
    | a <= b    = b
    | otherwise = a
--where Bindings
bmiTell :: Double -> Double -> String
bmiTell weight height
    | bmi <= skinny = "Underweight"
    | bmi <= normal = "Normal"
    | bmi <= fat    = "Overweight"
    | otherwise     = "Obese"
    where bmi = weight / height ^ 2
          skinny = 18.5
          normal = 25.0
          fat = 30.0

-- Pattern matching in where
where bmi = weight / height ^ 2
      (skinny, normal, fat) = (18.5, 25.0, 30.0)

--let bindings
-- let in expressions
cylinder :: Double -> Double -> Double
cylinder r h =
    let sideArea = 2 * pi * r * h
        topArea = pi * r ^ 2
    in sideArea + 2 * topArea

-- let in list comprehensions
[bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi > 25.0]
--case Expression
head' :: [a] -> a
head' xs = case xs of []    -> error "No head for empty lists!"
                       (x:_) -> x

describeList :: [a] -> String
describeList ls = "The list is " ++ case ls of []  -> "empty."
                                                 [x] -> "a singleton list."
                                                 xs  -> "a longer list."




--ch4 Recursion
-- Maximum of a list
maximum' :: Ord a => [a] -> a
maximum' [] = error "maximum of empty list!"
maximum' [x] = x
maximum' (x:xs) = max x (maximum' xs)

-- Replicate
replicate' :: Int -> a -> [a]
replicate' n x
    | n <= 0    = []
    | otherwise = x : replicate' (n-1) x

-- Take
take' :: Int -> [a] -> [a]
take' n _
    | n <= 0   = []
take' _ []     = []
take' n (x:xs) = x : take' (n-1) xs

-- Reverse
reverse' :: [a] -> [a]
reverse' [] = []
reverse' (x:xs) = reverse' xs ++ [x]

-- Repeat (infinite list)
repeat' :: a -> [a]
repeat' x = x : repeat' x

-- Zip
zip' :: [a] -> [b] -> [(a,b)]
zip' _ [] = []
zip' [] _ = []
zip' (x:xs) (y:ys) = (x,y) : zip' xs ys

-- QuickSort
quicksort :: Ord a => [a] -> [a]
quicksort [] = []
quicksort (x:xs) =
    let smallerOrEqual = [a | a <- xs, a <= x]
        larger = [a | a <- xs, a > x]
    in quicksort smallerOrEqual ++ [x] ++ quicksort larger
